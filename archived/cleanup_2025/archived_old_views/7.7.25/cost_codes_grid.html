{% extends "base.html" %}

{% block title %}Cost Codes with Groups - Simonini Grid{% endblock %}

{% block page_title %}üìã Cost Codes with Groups{% endblock %}

{% block toolbar_right %}
    <a href="/" class="btn" style="background: #6c757d; margin-right: 15px;">üè† Dashboard</a>
    <button type="button" class="btn" onclick="saveChanges()">üíæ Save Changes</button>
    <button type="button" class="btn" onclick="addNewRow()">‚ûï Add New</button>
    <button type="button" class="btn" onclick="refreshGrid()">üîÑ Refresh</button>
    <div class="btn-group" style="margin-left: 10px;">
        <button type="button" class="btn dropdown-toggle" data-bs-toggle="dropdown">üìä Export</button>
        <ul class="dropdown-menu">
            <li><a class="dropdown-item" href="#" onclick="exportToExcel()">üìà Export Excel</a></li>
            <li><a class="dropdown-item" href="#" onclick="exportToCsv()">üìä Export CSV</a></li>
        </ul>
    </div>
    <div class="btn-group">
        <button type="button" class="btn dropdown-toggle" data-bs-toggle="dropdown">üì• Import</button>
        <ul class="dropdown-menu">
            <li><a class="dropdown-item" href="#" onclick="downloadTemplate('excel')">üìã Download Excel Template</a></li>
            <li><a class="dropdown-item" href="#" onclick="downloadTemplate('csv')">üìã Download CSV Template</a></li>
            <li><hr class="dropdown-divider"></li>
            <li><a class="dropdown-item" href="#" onclick="triggerImport()">üì• Import File</a></li>
        </ul>
    </div>
{% endblock %}

{% block head %}
    <!-- Bootstrap CSS for dropdowns -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
        }
        .btn-group .btn {
            margin-left: 0;
        }
        .dropdown-menu {
            background: var(--white);
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .dropdown-item {
            color: var(--text);
            padding: 8px 16px;
        }
        .dropdown-item:hover {
            background: var(--offwhite);
            color: var(--navy);
        }
        .grid-info {
            background: var(--white);
            padding: 16px 32px;
            margin: 0 auto 2rem auto;
            max-width: 1400px;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(24,38,65,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #666;
        }
        /* File input styling */
        #fileInput {
            display: none;
        }
    </style>
{% endblock %}

{% block grid %}
    <!-- Status Messages -->
    <div id="statusMessage" class="status-message"></div>
    
    <!-- Hidden file input for import -->
    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" onchange="handleFileImport(event)">
    
    <!-- Global Filter -->
    <div style="max-width: 1400px; margin: 0 auto 1rem auto; display: flex; align-items: center;">
        <input id="globalFilterInput" type="text" class="form-control" style="max-width: 350px; margin-right: 1rem;" placeholder="üîé Filter any column..." oninput="onGlobalFilterChanged()">
        <span style="color: #888; font-size: 13px;">Type to filter all columns</span>
    </div>

    <!-- Grid Info -->
    <div class="grid-info">
        <div>
            <span id="rowCount">0</span> records | 
            <span id="selectedCount">0</span> selected |
            <span id="filteredCount">0</span> filtered
        </div>
        <div>
            Double-click to edit | Right-click for context menu | Ctrl+S to save
        </div>
    </div>
{% endblock %}

{% block scripts %}
    <!-- Bootstrap JavaScript for dropdowns -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // AG-Grid License Key from Flask config
        const AG_GRID_LICENSE_KEY = '{{ config.AG_GRID_LICENSE_KEY }}';
        
        // Set AG-Grid Enterprise License
        console.log('AG-Grid Enterprise: Setting license key...');
        if (AG_GRID_LICENSE_KEY && AG_GRID_LICENSE_KEY.length > 50) {
            agGrid.LicenseManager.setLicenseKey(AG_GRID_LICENSE_KEY);
            console.log('‚úÖ AG-Grid Enterprise license activated');
        } else {
            console.warn('‚ö†Ô∏è  AG-Grid license key not properly configured');
        }

        let gridApi;
        let originalData = [];
        let modifiedRows = [];

        // Grid options with Simonini styling
        const gridOptions = {
            columnDefs: [
                {
                    headerName: "Cost Code",
                    field: "cost_code",
                    sortable: true,
                    filter: 'agSetColumnFilter',
                    filterParams: {
                        buttons: ['reset', 'apply'],
                        closeOnApply: true,
                        suppressSelectAll: false,
                        newRowsAction: 'keep'
                    },
                    editable: true,
                    pinned: 'left',
                    width: 120,
                    cellStyle: { fontWeight: 'bold', color: '#182641' }
                },
                {
                    headerName: "Description",
                    field: "cost_code_description",
                    sortable: true,
                    filter: 'agSetColumnFilter',
                    filterParams: {
                        buttons: ['reset', 'apply'],
                        closeOnApply: true,
                        suppressSelectAll: false,
                        newRowsAction: 'keep'
                    },
                    editable: true,
                    flex: 2,
                    // Removed tooltipField to prevent flashing on hover
                    wrapText: true,
                    autoHeight: true
                },
                {
                    headerName: "Group Code",
                    field: "cost_group_code",
                    sortable: true,
                    filter: 'agSetColumnFilter',
                    filterParams: {
                        buttons: ['reset', 'apply'],
                        closeOnApply: true,
                        suppressSelectAll: false,
                        newRowsAction: 'keep'
                    },
                    editable: true,
                    width: 120,
                    cellStyle: { backgroundColor: '#f7f7f7', color: '#ad9244', fontWeight: '600' }
                },
                {
                    headerName: "Group Name",
                    field: "cost_group_name",
                    sortable: true,
                    filter: 'agSetColumnFilter',
                    filterParams: {
                        buttons: ['reset', 'apply'],
                        closeOnApply: true,
                        suppressSelectAll: false,
                        newRowsAction: 'keep'
                    },
                    editable: true,
                    flex: 1
                    // Removed tooltipField to prevent flashing on hover
                }
            ],

            // Default column configuration
            defaultColDef: {
                sortable: true,
                filter: true,
                resizable: true,
                editable: false,
                cellEditor: 'agTextCellEditor',
                filterParams: {
                    buttons: ['reset', 'apply'],
                    miniFilter: true,
                    applyMiniFilterWhileTyping: true,
                }
            },

            // Grid options with Enterprise features
            enableRangeSelection: true,
            enableBrowserTooltips: false,
            tooltipShowDelay: 1000, // Increased delay to reduce tooltip flickering
            animateRows: true,
            rowSelection: 'multiple',
            suppressRowClickSelection: true,
            enableCellTextSelection: true,
            ensureDomOrder: true,
            
            // Pagination
            pagination: true,
            paginationPageSize: 50,
            paginationAutoPageSize: false,

            // Editing
            stopEditingWhenCellsLoseFocus: true,
            singleClickEdit: false,
            
            // Event handlers
            onGridReady: onGridReady,
            onCellValueChanged: onCellValueChanged,
            onFilterChanged: onFilterChanged,
            onSelectionChanged: onSelectionChanged,
            
            // Row styling for modified rows
            getRowStyle: function(params) {
                if (modifiedRows.includes(params.node.id)) {
                    return { backgroundColor: '#ffe8a2' };
                }
                return null;
            }
        };

        // Add enterprise context menu
        gridOptions.getContextMenuItems = getContextMenuItems;

        // Track if grid has been initialized to prevent duplicate initializations
        let gridInitialized = false;
        
        // Initialize grid when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded event at', new Date().toISOString());
            if (gridInitialized) {
                console.warn('Attempted to initialize grid more than once! Skipping...');
                return;
            }
            
            try {
                console.log('Initializing grid...');
                const gridDiv = document.querySelector('#grid');
                if (!gridDiv) {
                    console.error('Grid container not found in DOM!');
                    return;
                }
                
                gridInitialized = true;
                
                // Handle unhandled promise rejections that could cause the "message channel closed" error
                window.addEventListener('unhandledrejection', function(event) {
                    console.warn('Unhandled promise rejection:', event.reason);
                    // Prevent the error from bubbling up
                    event.preventDefault();
                    
                    // If grid is stuck in loading state, show an error message
                    if (isLoadingData) {
                        isLoadingData = false;
                        showStatus('Error loading data: ' + (event.reason?.message || 'Unknown error'), 'error');
                        
                        // If grid exists but has no data, show error message in grid
                        if (gridApi && (!originalData || originalData.length === 0)) {
                            const errorData = [{
                                cost_code: 'ERROR',
                                cost_code_description: 'Failed to load data. Please try refreshing the page.',
                                cost_group_code: '',
                                cost_group_name: ''
                            }];
                            gridApi.setGridOption('rowData', errorData);
                        }
                    }
                });
                
                // Monitor for any errors or unexpected behavior
                window.addEventListener('error', function(event) {
                    console.error('Global error caught:', event.message, 'at', 
                                  event.filename, ':', event.lineno);
                });
                
                // Create grid with error handling
                try {
                    gridApi = agGrid.createGrid(gridDiv, gridOptions);
                } catch (err) {
                    console.error('Error creating AG Grid:', err);
                    gridDiv.innerHTML = '<div class="alert alert-danger">Error initializing grid. Please refresh the page.</div>';
                    return;
                }
                
                // Disable any auto-refresh meta tags that might exist
                const metaTags = document.getElementsByTagName('meta');
                for (let i = 0; i < metaTags.length; i++) {
                    if (metaTags[i].httpEquiv === 'refresh') {
                        console.warn('Found auto-refresh meta tag! Removing...');
                        metaTags[i].parentNode.removeChild(metaTags[i]);
                    }
                }
            } catch (err) {
                console.error('Critical error during grid initialization:', err);
                const gridContainer = document.querySelector('#grid');
                if (gridContainer) {
                    gridContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <strong>Error initializing grid:</strong> ${err.message}
                            <br><br>
                            <button class="btn btn-primary" onclick="location.reload()">Reload Page</button>
                        </div>
                    `;
                }
            }
        });

        // Track if data is currently being loaded to prevent multiple simultaneous loads
        let isLoadingData = false;
        // Track last load time to prevent frequent reloads
        let lastLoadTime = 0;
        // Local storage cache key for cost codes data
        const CACHE_KEY = 'cost_codes_data_cache';
        // Cache expiration time (30 minutes)
        const CACHE_EXPIRY = 30 * 60 * 1000;
        // Minimum time between data refreshes (30 seconds)
        const REFRESH_THROTTLE = 30000;
        // Debug flag - show background data loads in console only
        const DEBUG_LOADS = false;
        
        // Check if we have valid cached data in local storage
        function getLocalCache() {
            try {
                const cachedData = localStorage.getItem(CACHE_KEY);
                if (!cachedData) return null;
                
                const cache = JSON.parse(cachedData);
                // Check if cache has expired
                if (Date.now() > cache.expiry) {
                    console.log('Cache expired, clearing');
                    localStorage.removeItem(CACHE_KEY);
                    return null;
                }
                
                console.log(`Using cached data from ${new Date(cache.timestamp).toLocaleTimeString()}`);
                return cache.data;
            } catch (e) {
                console.error('Error reading from cache:', e);
                return null;
            }
        }
        
        // Save data to local storage cache
        function setLocalCache(data) {
            try {
                const cache = {
                    data: data,
                    timestamp: Date.now(),
                    expiry: Date.now() + CACHE_EXPIRY
                };
                localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
                console.log('Data cached in local storage');
            } catch (e) {
                console.error('Error writing to cache:', e);
            }
        }
        
        // Load data from server
        async function loadData(forceRefresh = false) {
            // For the first load, bypass the throttling
            const isFirstLoad = lastLoadTime === 0;
            const now = Date.now();
            
            // Check if already loading data
            if (isLoadingData) {
                console.log('Skipping data load - already in progress');
                return;
            }
            
            // Check throttling (unless forced refresh or first load)
            if (!forceRefresh && !isFirstLoad && (now - lastLoadTime < REFRESH_THROTTLE)) {
                console.log(`Throttling data load - last load was ${Math.round((now - lastLoadTime)/1000)}s ago`);
                return;
            }
            
            // Set status message only for forced refreshes (user initiated)
            if (forceRefresh) {
                showStatus('Loading data...', 'info');
            }
            
            // Try to get data from local cache first (unless forced refresh)
            if (!forceRefresh) {
                const cachedData = getLocalCache();
                if (cachedData && cachedData.length > 0) {
                    if (gridApi) {
                        console.log(`Loading ${cachedData.length} records from cache`);
                        originalData = cachedData;
                        gridApi.setGridOption('rowData', cachedData);
                        updateRowCount();
                        showStatus(`Loaded ${cachedData.length} cost codes from cache`, 'info');
                    }
                    
                    // If we're not at first load and not forcing refresh, we can return here
                    // This prevents unnecessary API calls while still showing data
                    if (!isFirstLoad && !forceRefresh) {
                        return;
                    }
                    // Otherwise continue to fetch fresh data in the background
                }
            }
            
            try {
                isLoadingData = true;
                console.log('Loading cost codes data...', new Date().toISOString(), 
                          isFirstLoad ? '(first load)' : forceRefresh ? '(forced refresh)' : '');
                showStatus('Loading data...', 'info');
                
                // Set a 10-second timeout for the fetch operation
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                try {
                    // Add cache-busting parameter if forcing refresh
                    // For first load, always bypass client cache to ensure we get data
                    const url = (forceRefresh || isFirstLoad) ? 
                        '/api/cost-codes-with-groups?no-cache=true&t=' + Date.now() : 
                        '/api/cost-codes-with-groups';
                        
                    console.log('Fetching data from:', url);
                    
                    const response = await fetch(url, {
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    console.log('Response received:', response.status, response.ok);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Check if we got valid data
                    if (!Array.isArray(data)) {
                        console.error('Received non-array data:', data);
                        throw new Error('Invalid data format received from server');
                    }
                    
                    console.log('Data loaded successfully:', data.length, 'records');
                    
                    if (!gridApi) {
                        console.error('GridAPI is not available!');
                        if (forceRefresh) showStatus('Grid not ready yet', 'error');
                        isLoadingData = false;
                        return;
                    }
                    
                    // Only update grid if data has changed or force refresh
                    const dataChanged = JSON.stringify(data) !== JSON.stringify(originalData);
                    if (dataChanged || forceRefresh) {
                        // Update timestamp of last successful load
                        lastLoadTime = Date.now();
                        // Save the data to local storage cache
                        setLocalCache(data);
                        
                        originalData = data;
                        gridApi.setGridOption('rowData', data);
                        updateRowCount();
                        
                        // Only show status message for forced refreshes or when data changed
                        if (forceRefresh) {
                            showStatus(`Loaded ${data.length} cost codes successfully`, 'success');
                        } else if (dataChanged && DEBUG_LOADS) {
                            console.log(`Data changed, refreshed ${data.length} records silently`);
                        }
                    } else {
                        console.log('Data unchanged, no grid update needed');
                    }
                    console.log('Data loading complete');
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    
                    // Check if it's an abort error (timeout)
                    if (fetchError.name === 'AbortError') {
                        throw new Error('Request timed out. The server may be overloaded.');
                    }
                    
                    throw fetchError; // Re-throw for the outer catch block
                }
            } catch (error) {
                console.error('Error loading data:', error);
                showStatus('Error loading data: ' + error.message, 'error');
                
                // If there's an error and the grid is empty, show an error message in the grid
                if (gridApi && (!originalData || originalData.length === 0)) {
                    const errorData = [{
                        cost_code: 'ERROR',
                        cost_code_description: 'Failed to load data: ' + error.message + '. Try clicking the Refresh button.',
                        cost_group_code: '',
                        cost_group_name: ''
                    }];
                    gridApi.setGridOption('rowData', errorData);
                }
            } finally {
                isLoadingData = false;
            }
        }

        // Grid ready event
        function onGridReady(params) {
            console.log('Grid ready event fired at', new Date().toISOString());
            gridApi = params.api; // Always set gridApi to the current instance
            console.log('Setting up grid API and loading data...');
            params.api.sizeColumnsToFit();
                
                // Add debug monitoring of network requests to detect multiple reloads
                if (window.performance && window.PerformanceObserver) {
                    try {
                        const observer = new PerformanceObserver((list) => {
                            list.getEntries().forEach((entry) => {
                                if (entry.initiatorType === 'fetch' && 
                                    entry.name.includes('/api/cost-codes-with-groups')) {
                                    console.log('Network request detected:', 
                                                entry.name, 
                                                'at', new Date(entry.startTime).toISOString(),
                                                'duration:', entry.duration);
                                }
                            });
                        });
                        observer.observe({entryTypes: ['resource']});
                        console.log('Performance monitoring enabled');
                    } catch (e) {
                        console.warn('Performance monitoring failed to initialize:', e);
                    }
                }
                
                // Always load data when grid is ready, but avoid immediate refresh
                console.log('Initializing data load...');
                loadData(false); // Load with cache first, don't force refresh on initial load
        }

        // Cell value changed event
        function onCellValueChanged(event) {
            const rowId = event.node.id;
            if (!modifiedRows.includes(rowId)) {
                modifiedRows.push(rowId);
            }
            gridApi.refreshRows({ rowNodes: [event.node] });
            showStatus('Row modified. Click "Save Changes" to update database.', 'warning');
        }

        // Filter changed event
        function onFilterChanged() {
            updateRowCount();
        }

        // Selection changed event
        function onSelectionChanged() {
            updateRowCount();
        }


        // Context menu items
        function getContextMenuItems(params) {
            return [
                {
                    name: 'Edit Row',
                    action: function() {
                        if (params.node) {
                            startEditingRow(params.node);
                        }
                    },
                    icon: '<i class="fa fa-edit"></i>'
                },
                {
                    name: 'Duplicate Row',
                    action: function() {
                        if (params.node) {
                            duplicateRow(params.node);
                        }
                    },
                    icon: '<i class="fa fa-copy"></i>'
                },
                'separator',
                {
                    name: 'Copy Cell',
                    action: function() {
                        if (params.value) {
                            navigator.clipboard.writeText(params.value);
                            showStatus('Copied to clipboard', 'success');
                        }
                    }
                },
                {
                    name: 'Copy Row',
                    action: function() {
                        if (params.node) {
                            const rowData = params.node.data;
                            const text = Object.values(rowData).join('\t');
                            navigator.clipboard.writeText(text);
                            showStatus('Row copied to clipboard', 'success');
                        }
                    }
                },
                'separator',
                'export'
            ];
        }

        // Start editing a row
        function startEditingRow(node) {
            const columns = gridApi.getColumns();
            if (columns && columns.length > 0) {
                gridApi.startEditingCell({
                    rowIndex: node.rowIndex,
                    colKey: columns[0].getColId()
                });
            }
        }

        // Save changes to server
        async function saveChanges() {
            if (modifiedRows.length === 0) {
                showStatus('No changes to save', 'info');
                return;
            }

            try {
                showStatus('Saving changes...', 'info');
                const updates = [];
                
                modifiedRows.forEach(rowId => {
                    const node = gridApi.getRowNode(rowId);
                    if (node) {
                        updates.push(node.data);
                    }
                });

                const response = await fetch('/api/cost-codes-with-groups/bulk-update', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ updates: updates })
                });

                const result = await response.json();
                
                if (result.success) {
                    modifiedRows = [];
                    gridApi.refreshRows();
                    showStatus(`Successfully updated ${updates.length} records`, 'success');
                } else {
                    showStatus('Error saving changes: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error saving changes:', error);
                showStatus('Error saving changes: ' + error.message, 'error');
            }
        }

        // Add new row
        function addNewRow() {
            const newRow = {
                cost_code: '',
                cost_code_description: '',
                cost_group_code: '',
                cost_group_name: ''
            };
            
            gridApi.applyTransaction({ add: [newRow], addIndex: 0 });
            
            // Start editing the new row
            setTimeout(() => {
                const firstNode = gridApi.getDisplayedRowAtIndex(0);
                if (firstNode) {
                    startEditingRow(firstNode);
                    modifiedRows.push(firstNode.id);
                }
            }, 100);
            
            showStatus('New row added. Fill in the details and save.', 'info');
        }

        // Refresh grid
        function refreshGrid() {
            modifiedRows = [];
            // Clear local storage cache first
            try {
                localStorage.removeItem(CACHE_KEY);
                console.log('Cache cleared before refresh');
            } catch (e) {
                console.warn('Failed to clear cache:', e);
            }
            // Force refresh from server bypassing cache
            loadData(true);
        }

        // Export functions
        function exportToExcel() {
            window.location.href = '/api/cost-codes-with-groups/export/excel';
            showStatus('Excel export started', 'success');
        }

        function exportToCsv() {
            window.location.href = '/api/cost-codes-with-groups/export/csv';
            showStatus('CSV export started', 'success');
        }

        // Template download functions
        function downloadTemplate(format) {
            window.location.href = `/api/cost-codes-with-groups/template/${format}`;
            showStatus(`${format.toUpperCase()} template download started`, 'success');
        }

        // Import functions
        function triggerImport() {
            document.getElementById('fileInput').click();
        }

        async function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            try {
                showStatus('Importing file...', 'info');
                
                const response = await fetch('/api/cost-codes-with-groups/import', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    showStatus(result.message, 'success');
                    refreshGrid(); // Reload data to show imported records
                } else {
                    showStatus('Import failed: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error importing file:', error);
                showStatus('Error importing file: ' + error.message, 'error');
            }

            // Reset file input
            event.target.value = '';
        }

        // Update row count display
        function updateRowCount() {
            if (!gridApi) return;
            
            const totalRows = gridApi.getDisplayedRowCount();
            const selectedRows = gridApi.getSelectedRows().length;
            const filteredRows = totalRows; // Use displayed count for community version
            
            document.getElementById('rowCount').textContent = totalRows;
            document.getElementById('selectedCount').textContent = selectedRows;
            document.getElementById('filteredCount').textContent = filteredRows;
        }

        // Show status message
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessage');
            const alertClass = {
                'success': 'alert-success',
                'error': 'alert-danger',
                'warning': 'alert-warning',
                'info': 'alert-info'
            }[type] || 'alert-info';
            
            statusDiv.innerHTML = `<div class="alert ${alertClass} alert-dismissible fade show" role="alert">
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>`;
            
            // Auto-dismiss after 5 seconds for success/info messages
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    const alert = statusDiv.querySelector('.alert');
                    if (alert) {
                        const bsAlert = new bootstrap.Alert(alert);
                        bsAlert.close();
                    }
                }, 5000);
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        saveChanges();
                        break;
                    case 'n':
                        e.preventDefault();
                        addNewRow();
                        break;
                    case 'r':
                        e.preventDefault();
                        refreshGrid();
                        break;
                }
            }
        });

        // Global filter logic
        function onGlobalFilterChanged() {
            const filterValue = document.getElementById('globalFilterInput').value;
            if (gridApi) {
                gridApi.setQuickFilter(filterValue);
                updateRowCount();
            }
        }

        // Duplicate row logic
        function duplicateRow(node) {
            if (!node || !node.data) return;
            // Shallow copy the row data, clear cost_code to force user to enter a new one
            const newRow = { ...node.data, cost_code: '' };
            gridApi.applyTransaction({ add: [newRow], addIndex: node.rowIndex + 1 });
            setTimeout(() => {
                const newNode = gridApi.getDisplayedRowAtIndex(node.rowIndex + 1);
                if (newNode) {
                    startEditingRow(newNode);
                    modifiedRows.push(newNode.id);
                }
            }, 100);
            showStatus('Row duplicated. Edit and save.', 'info');
        }
    </script>
{% endblock %}
